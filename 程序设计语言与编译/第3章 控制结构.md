# 控制结构Control Structure

## 3.1 引言

程序

- 对数据对象的表示
- 各类数据操作，按顺序执行
- 描述执行顺序的机制，即描述算法的工作

## 3.2 语句级控制结构(Statement-level Control)

- 顺序（Sequencing）
- 选择（Selection）
- 重复（Repetition）

## 3.3 单元级控制结构(Unit-level Control)

### 顺序结构

模型：

```sh
A;B
```

`;`分隔语句的控制算符，顺序运算符（Sequencing Operator）

复合语句（Computed Statement）：若干语言通过顺序运算符组合在一起作为一个单独的语句。

```sh
S1;S2;S3
```

### 选择结构

模型

```sh
IF(I.GT.0) I = I-1
```

如果I>0，则 `i = i-1`

二义性（Ambiguity）,内层分支造成二义性

- 最近匹配原则 => 消除了二义性，但是多层嵌套，读起来也很困难。
- 明确if结构分支，防止多层嵌套的误解

case 多重选择 根据表达式的值规定分支的选择 

- 表达式值在分支
- 表达式值不在分支i:out、skip

### 卫哨模型 Guard 护卫模型

Dij kstra 1976年提出

- 对非确定化的抽象
- 为并行计算和实时处理提供了良好的结果

卫哨命令表示法

```js
if B1 --> S1
	B2--> s2
	BN---> SN
fi
```

- Bi(1<=I<=N) 布尔表达式，称为卫哨（Guard）
- Si(1<=i<=N)语句
- BI--> SI卫哨命令(Guraded Command)

在实时处理中，应用这种结构非常方便。例如，在某个控制系统中，卫哨作为控制条件，在某一时刻有多个卫哨同时计算为真，就可能同时去执行几个任务，也可以根据响应时间的要求，去执行最紧迫的任务。

### 重复结构

在程序设计中，一个上亿次计算的任务，不可能写出上亿条的指令让计算机执行，唯一可行的方法是使许多指令重复执行。因此，许多语言都提供了这样的控制结构，它允许程序员规定在某些语句(指令)上循环。

计数器制导（Counter driven）: 提前制导重复次数

条件制导（Condition-driven）:一般是一个布尔表达式，一直重复到布尔表达式的值改变。不知道运行的次数

	- while-do 任意重复，包括0次
	- repeat-util 重复一次以上

```js
// 文件处理程序
while not eof(f)do
    begin
    	"从文件中读一个项"
		"处理这个项"
	end
```

在执行循环体之前，先要计算eof(它是文件尾标，这里主要是查文件尾标)，只要eof(f)不是文件尾标，not eof(f)总为真，执行循环体，直到文件尾标查到，这时not eof(f)为假，停止循环。因此，这个程序对空文件也是正确的，这时一次都不执行循环体。

```js
repeat 
	"从文件f中读一个项"
	"处理这个项"
util eof(f)
```

### 语句级结构分析

goto语句：任意修改程序计算器的抽象

goto(Dij kstra): goto语句：

- 隐藏出错的机会
- 使得程序的正确性证明变得困难。
- 破坏了程序各语句的顺序连续性，违反常规习惯

Böhm和Jacopini于1966年在理论上证明，使用顺序、选择(if then else)和重复(do while)就可以对计算机所有可能的算法进行编码。因此，这3种结构组成了控制结构的有效集合。然而，仅使用这3种控制结构写出的程序不太自然，更可能产生拙劣的程序。实际上，增加一些控制结构(例如，增加多重选择case，计算器制导循环for和条件制导循环repeat-until等)，虽然在理论上是多余的，但这样的确能提高程序的可写性和可读性。