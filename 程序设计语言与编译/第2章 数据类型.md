# 第2章 数据类型（Data Type）

## 2.1 引言

所谓程序，实质上就是在数据的某些特定的表示方式和结构的基础上对抽象算法的具体描述。

算法+数据结构=程序

Data Type ==> 数据结构

控制结构 ==> 算法

数据类型实质上是对存储器中所存储的数据的抽象。在机器语言中，存储器的一个存储单元的内容是一个二进制位串(序列)。这些位串实际可能是一条机器指令、一个地址、一个整数、一个实数或一个字符(串)，它们在存储器中的意义直接受程序员的控制，程序员可用移位、逻辑运算和算术运算等操作对它们进行处理。在机器语言中，数据具有最原始的形式，没有任何的抽象。（汇总，用一个符号代码一大堆信息。）

早期的汇编语言的抽象只有符号名，程序员使用助记符命名操作码，也可用符号命名存储位置(单元)。即使这样简单的抽象，也使程序员受益匪浅，至少可以从机器的具体特征，特别是表示存储地址和操作的二进制位串中解脱出来，同时也提高了程序的可写性、可读性和可修改性(Modifiability)。

每种数据类型定义一组值的集合，以及对这组值进行的操作(运算)的集合。

语言的某种特定的数据抽象受到两个因素的影响：一是语言所面向的机器(只提供定点运算或同时提供浮点运算)；二是语言所面向的应用领域。

FORTRAN不适合串处理的问题，COBOL不适合解微分方程的计算

内部类型（Built-in Type）:语言根据所面向的机器和应用定义了不同的数据类型，这些类型称为内部类型。

用户定义类型（User-defined Type）:用户自己定义的数据类型

## 2.1 内部类型

计算机程序可以看成作用于某些输入，产生某些期望的结果(输出)的函数。在传统的语言中，函数计算是分步进行的，每一步都可能产生中间结果(Intermediate Result)，并将它存储在程序变量中。

语言提供一些内部类型，这些类型又称语言定义类型(Language-defined Type)，它们多数都能反映基本硬件特性。

1. 基本表示的不可见性

   - 程序员不能访问表示某类型的值的基本位串，这些基本位串对程序员是不可见的。

   - 机器运算后的结果表示不可见，可见的翻译之后的新值结果

     优点：

     （1）不同的程序设计风格

     （2）可写型：可写性是一个难以度量的性质，一般是指对某个问题以习惯和自然的方式来表述一个程序的可能性，以便程序员不必注意语言的细枝末节和技巧，把精力集中在问题求解上。

     （3）可读性：语言的可读性表现在用该语言编制的程序可进行逻辑跟踪，通过跟踪程序进行校验，发现程序中所出现的错误。可读性也是一个主观准则，它在很大程度上依赖于感觉和风格。

     （4）可修改性：语言提供了读/写内部类型值的语句，大多数语言还提供了格式输出功能。实际机器以一种结构复杂的方法解释这些格式，让外部设备来执行输入/输出，不同的机器有不同的解释方法，而高级语言掩盖了包含在输入/输出中的复杂物理资源(例如寄存器、通道等)。

2. 编译时能检查变量使用的正确性

   编译程序在编译时要对类型进行检查，编译时的类型检查称为静态类型检查(Static Type Checking)。静态类型检查不可能将一个程序中的所有数据操作错误检查出来，有的错误还需在运行时检查。

3. 编译时可以确定无二义的操作

   ，语言都用少数几个运算符来表示大量的操作，例如运算符“+”可以表示整数加，也可以表示实数加，有的语言甚至用来表示逻辑加。涉及执行表达式A+B的机器操作可由编译器来确定，因为编译时A和B的类型是确定的，编译器可根据A和B的类型来确定相应的操作。运算符的意义依赖于操作数的类型，它称为超载(或重载)(Overload)或多态(Polymor-phic)。(Polymor-phic)。运算符“+”是超载的例子，它对整数加和实数加都有意义，编译时以不同的机器指令来实现。如果一个语言不允许运算符出现超载，那么，对不同的操作就要引入不同的运算符，这就使得语言定义变得冗长，程序员记忆的符号也要增加。若语言使一个运算符表示过多的操作，那么程序就变得难于理解。因此，合理地使用超载，可以提高语言的可读性和可用性(Usability)。

4. 精度控制

精度说明可以看成编译程序实施空间优化的命令，也可以看成对编译程序插入监控变量值的运行时检查。后者为估计计算结果的正确性提供了有效途径。精度说明也为程序员提供了不同情况采用不同存储字长的手段，以便有效地利用存储空间。程序的修改也很容易，若只需改变相应的字长，就仅限于改变源程序中的相关类型说明。

## 2.3 用户定义类型

语言允许程序员规定基本数据对象的聚合(Aggregate)，乃至聚合的聚合。

### 笛卡尔积

现在，我们有两个集合A和B。

A = {0,1}   B = {2,3,4}

集合 A×B 和 B×A的结果集就可以分别表示为以下这种形式：

A×B = {（0，2），（1，2），（0，3），（1，3），（0，4），（1，4）}；

B×A = {（2，0），（2，1），（3，0），（3，1），（4，0），（4，1）}；

以上A×B和B×A的结果就可以叫做两个集合相乘的‘笛卡尔积’。

从以上的数据分析我们可以得出以下两点结论：

1，两个集合相乘，不满足交换率，既 A×B ≠ B×A;

2，A集合和B集合相乘，包含了集合A中元素和集合B中元素相结合的所有的可能性。既两个集合相乘得到的新集合的元素个数是 A集合的元素个数 × B集合的元素个数;

正多边形描述

边数为interger N+,边的长度为 R+,

那么正多边形描述为` N+ * R+`

pascal定义一个正多边形

```pascal
type polygon = record no_od_edges:interger;
		edge_size:real;
end
```

语言把笛卡儿积数据对象看成由若干个域(Field)组成，每一个域都可以具有一个名字。在上述正多边形的例子中，以polygon命名变量的类型，它的每个变量具有两个域，一个名为no_of_edges的整型域，用来保存边数，一个名为edge_size的实型域，用来保存边的长度。笛卡儿积的域可用域名(Field Name)来选取，也可用语言规定的选择符(Selector)来选取。

取长为7.53的等边三角形

```pascal
tl.no_of_edges:=3;
tl:edge_suze:=7.53;
```

### 有限映像（Fi-nite Mapping）

从定义域类型DT值的有限集合到值域类型RT值的有限集合。

```js
var a:array[1..50] of char
```

变量a为1-50整数集合到字符集的有限映像。值域的对象可由下标索引(Indexing)来选取，即通过在定义域中提供相应的值作为下标(Index)来选取。a[k]称为下标变量(Indexed Variable)。带有不在定义域中值的下标会导致一个错误，例如a[55]就是对上述数组元素的一个引用错误。通常，这类错误要在运行时才能查出。

下标可用来选取值域的多个元素。Ada的a [3..20]说明一个包含18个元素的a的一维子数组(Subarray)，这样的操作称为分割(Sli-cing)，它选取数组的一个切片(Slice)。

有限映像定义域类型DT到相应值的特定子集的绑定策略随语言而异，它有三种基本方式。

(1)编译时绑定例如FORTRAN，C和Pascal语言，程序员在编写程序时这个子集就已固定，所以在编译时就能冻结。

(2)对象建立时绑定ALGOL 60最先采用这种限制，后来在SIMULA 67和Ada中也得到采用。在程序运行时，变量实例一旦建立，子集就固定了。

(3)对象处理时绑定这是在运行时期内执行的选择，它是最灵活也是代价最高的选择。例如，ALGOL 68的灵活数组(Flexible Array)在运行中对象的生成期内，子集的范围是随时可变的，只有在处理对象时约束当前的子集范围。典型的动态语言SNOBOL 4和APL和后来的CLU都采用这种绑定。

### 序列

序列(Sequence)由任意多个数据项组成，这些项称为该序列的成分(Component)。每个成分都具有相同的类型，记为CT。在这种构造机制中，成分出现的个数不需要说明，原则上要求能容纳任意大小的对象。串是众所周知的序列，其成分类型为字符。

串的一般操作有下列4种：

(1)连接(Concatenation)串“THIS_IS_”和串“AN_EXAMPLE”的连接的结果是“THIS_IS_AN_EXAMPLE”。

(2)首项选取选取一个串的第一个成分，对上述连接的结果的首项选取是‘T’。

(3)尾项选取选取一个串的最后一个成分，对上述连接的结果的尾项选取是‘E’。

(4)子串以专门的说明指出从给定的串中取出期望的子串(Substring)，要求说明标出子串的第一个字符和最后一个字符的位置。

### 递归 Recursive Type

若数据类型T包含属于同一数据类型T的成分，那么类型T称为递归类型(Recursive Type)。递归类型允许在类型定义中使用被定义类型的名字。例如，二叉树可通过递归来定义。类型binary_tree可以定义成一个三元式，第一个元素或者为空，或者为原子元素(Atomic El-ement)；第二个元素为(Left)binary_tree；第三个元素为(Right)binary_tree (参见2.4.3节)。递归用来定义聚合的构造机制，这个聚合的大小是任意增加的，结构也可以很复杂。递归与序列相反，允许程序员为选取成分建立任意的访问路径。指针(Pointer)是语言提供的最常用的建立递归数据对象的机制。递归类型的每个成分由一个单元表示，存储单元的内容是一个指向数据对象的指针，而不是数据对象本身。常常会遇到这样的情况，即数据对象的大小是任意的，所以我们需要这样的指针，以间接方式来标识这类可变的数据对象。例如，二叉树的每个结点都具有两个相关单元，一个包含指向左子树的指针，另一个包含指向右子树的指针(这里忽略了每个结点还应保存的其他信息)。树自身用另一个单元来标识，这个单元包含指向树根的指针，从这个单元出发，沿着适当的指针链可以访问每个结点。空指针对应空(子)树。

### 判定或 Discriminated Union

是一个选择对象结构的构造机制，规定在两个不同选择对象之间做出适当的选择，每个选择对象结构称为一个变体(Variant)。

在公用数据处理中，有这样的情况：某些存储记录的结构绝大部分都是相同的，仅有少部分域是不同的，因此可使用判定或构造机制来定义不同的变体。

### 幂集 power-set

其值是某个类型T的各元素集合的任意子集，该变量的类型记为Powerset(T)，即类型T的元素的所有子集的集合。这种构造机制称为幂集(Pow-erset)，T称为基类型(Base TyPe)。

有点枚举的意思...

假设有集合Set{篮球，羽毛，乒乓球}，那么自己可为{篮球},{篮球，羽毛球}等。其类型为powerset(Set)。

类型powerset的变量是一个集合，因此对它们的基本操作是集合的操作，可以是“联合”、“与”，以及测试类型T的给定对象是否在这个集合中。有的语言缺乏支持集合的类型，为了表示幂集，程序员只好使用布尔数组、链表或其他低级机制来实现。

显式命名的优点：

（1）可读性

（2）可修改性

（3）可分性

（4）一致性检查

### 2.4Pascal语言类型结构

### 2.5 Ada语言数据类型结构

### 2.6 C语言数据类型结构

### 2.7 Java语言的数据类型

### 2.8 抽象数据类型

### 2.9 类型检查

### 2.10 类型转换

#### 2.11 类型等价

### 2.12 实现模型

